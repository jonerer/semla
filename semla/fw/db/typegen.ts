import { getModels, getUserModels, ModelType } from './models'
import get from '../config/config'
import { getAppBasedir } from '../appinfo'
import { readFileSync, writeFileSync, mkdirSync } from 'fs'
import { prettierify } from '../devtools/services/Prettierify'

const generateTypesContent = (models: ModelType[]) => {
    // make a little prelude
    // for each model, create a string for the interface, one for the import

    let infoHeader = `// This file was automatically generated by the Semla framework.\n`
    infoHeader +=
        '// DO NOT make any changes in this file; they will be overwritten anyway.\n'
    infoHeader +=
        '// DO make sure to add this to source control; it will not be regenerated in test or production environments\n'

    const prelude = `
    interface RelatedField<T> extends Promise<T> {
    id: number
    }
    
    interface QueryField {}
    
export class SemlaController {
    // implementations are provided by the framework at runtime
    render(view: string, locals: object | undefined) {}
    redirect(path: string) {}
    json(serializable: object) {}
}
    `

    // piece together the reqeust context interface thing
    let routeParamThings = ``
    for (const model of models) {
        routeParamThings +=
            model._routeParamName + ': ' + model._modelName + '\n'
    }
    let requestContextInterfaceThing = `
interface ParamsObject {
    allowed(...args): any
    [s: string]: any
}

export interface RequestContext {
    params: ParamsObject
    req: any // express req
    res: any // express res
    session: any
    ${routeParamThings}
    render(view: string, locals: object | undefined)
    redirect(path: string)
    json(serializable: object)
}
    `

    let modelsToImport: string[] = []
    let imports = ``

    let modelsBody = ``

    let settablesBody = ``

    for (const model of models) {
        let modelBody = 'export class ' + model._modelName + 'Base  {\n'

        modelsToImport.push(model._modelName)
        let all = model._fields.getAll()
        for (const field of model._relationFields) {
            if (field.type === 'belongsTo') {
                modelBody +=
                    field.jsName +
                    ': RelatedField<' +
                    field.targetModel?._modelName +
                    '>\n'
                modelBody += 'static ' + field.jsName + ': QueryField\n\n'
            } else if (field.type === 'hasMany') {
                modelBody +=
                    field.jsName +
                    ': RelatedField<' +
                    field.targetModel?._modelName +
                    '[]>\n\n'
            }
            modelsToImport.push(field.targetModel?._modelName!)
        }
        for (const field of all) {
            modelBody += field.jsName + ': ' + field.tsType + '\n'
            if (field.jsName === 'name') {
                modelBody += '    // @ts-ignore\n' // conflicts with built-in prototype constructor 'name'. really ignorable? unsure...
            }
            modelBody += 'static ' + field.jsName + ': QueryField\n\n'
            modelBody += 'static ' + field.jsName + '__not: QueryField\n\n'
        }

        const settableInterfaceName = model._modelName + 'Settable'
        let settableInterface = `interface ${settableInterfaceName} {\n`
        for (const field of all) {
            settableInterface +=
                field.jsName + '?: ' + field.tsType + ' | null' + '\n' // todo: nullability!
        }
        for (const field of model._relationFields.filter(
            x => x.type === 'belongsTo'
        )) {
            settableInterface +=
                field.jsName +
                '?: ' +
                'number | null | ' +
                field.targetModel?._modelName +
                ' | RelatedField<' +
                field.targetModel?._modelName +
                '>\n'
        }
        settableInterface += '}\n'
        settablesBody += settableInterface

        modelBody += '\n// instance methods\n'
        modelBody += `set: (obj: ${settableInterfaceName}) => void\n`
        modelBody += `save: () => Promise<${model._modelName}>\n`
        modelBody += '\n// AR methods\n'
        modelBody += 'static where: (from: any, to: any) => any\n'
        modelBody += 'static join: (from: any) => any\n'
        modelBody += 'static order: (from: any) => any\n'
        modelBody += `static find: (from?: any) => Promise<${model._modelName}[]>\n`
        modelBody += `static findOne: (from: any) => Promise<${model._modelName}>\n`
        modelBody += '}\n'

        modelsBody += modelBody + '\n'
    }

    let hasImported: string[] = []
    for (const impo of modelsToImport) {
        if (hasImported.indexOf(impo) !== -1) {
            continue
        }
        // todo: this assumes a lot about or project layout.
        //  best would be to intercept the source location from the "registerModel" call.
        imports += 'import { ' + impo + "} from '../models/" + impo + "'\n"
        hasImported.push(impo)
    }

    let s =
        imports +
        '\n\n' +
        infoHeader +
        '\n\n' +
        prelude +
        '\n\n' +
        requestContextInterfaceThing +
        '\n\n' +
        settablesBody +
        '\n\n' +
        modelsBody
    // return prettierify(s)
    return s
}

function getCurrentContent(targetFilePath: string) {
    try {
        return readFileSync(targetFilePath, 'utf-8')
    } catch (e) {
        return ''
    }
}

function writeNewContent(targetFilePath: string, content: string) {
    writeFileSync(targetFilePath, content, 'utf-8')
}

export const generateTypes = async () => {
    const shouldGenModels = get('codegen.models')
    if (shouldGenModels) {
        const models = getUserModels()
        let modelList: ModelType[] = []
        let anyNotLoaded = false
        for (const model of Object.values(models)) {
            modelList.push(model)
            if (!model.loaded()) {
                anyNotLoaded = true
            }
        }

        if (anyNotLoaded) {
            console.log(
                'No generating types; at least one model failed to load'
            )
            return
        }

        const content = generateTypesContent(modelList)
        const targetFilePath = getAppBasedir() + '/app/generated/types.ts'
        const currentContent = getCurrentContent(targetFilePath)
        if (content != currentContent) {
            writeNewContent(targetFilePath, content)
        }
    }
}
