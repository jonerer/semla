import get from '../config/config'
import { getLoadedUserModelList, getUserModels, ModelType } from './models'
import * as fs from 'fs'
import detectNewline from 'detect-newline'
import { Field } from './querying/fields'
import _ from 'underscore'

const { readFile, writeFile } = fs.promises

const PRELUDE =
    "This comment was generated by semla. Please don't change it\n" +
    '  * manually as your changes may be overwritten'
const TAG = 'generated by semla.'

/**
 * find the start of the current line. so search backwards to '\n'
 * @param {string} fullText
 * @param {string} location
 * @returns {number}
 */
function startOfLine(fullText, location) {
    const newLine = detectNewline(fullText)
    for (let i = location; i > 0; i--) {
        if (fullText.substr(i, newLine?.length) === newLine) {
            return i
        }
    }
    return 0
}

/** @typedef {Object} StartEnd
 * @property {number} start
 * @property {number} end
 */

/** Find the start and end of the comment tag or the class definition
 * @param definingFile the file to search in
 * @param model the model to search for
 * @returns {StartEnd}
 * */
export function findStartEnd(definingFile, model) {
    let start = 0,
        end = 0
    const tagLocation = definingFile.indexOf(TAG)
    if (tagLocation !== -1) {
        // if we have a tag, then find the location of the start of the tag line
        start = startOfLine(definingFile, tagLocation) // jump to before /*
        end = definingFile.indexOf('*/', start) + 2 + 1
    } else {
        // if we don't have a tag, find the location of the line preceding the
        // class definition
        let classDefinitionLocation = definingFile.indexOf(
            'class ' + model._modelName
        )
        start =
            startOfLine(definingFile, classDefinitionLocation) -
            detectNewline.graceful(definingFile).length +
            1
        end = start
    }
    return {
        start,
        end,
    }
}

/** Pad a string to the right with spaces
 * @param text
 * @param width
 * @returns {string}
 */
function padRight(text, width) {
    let count = width - text.length
    return text + ' '.repeat(count)
}

/** @typedef ColumnValues {[string,string,string,string]} */

/** Generate a line for a field
 * @param {Field} field
 * @returns {ColumnValues}
 */
export function lineForField(field) {
    let description = ''

    const relationField = field.relationField
    if (relationField) {
        const name = relationField.targetModel
            ? relationField.targetModel._modelName
            : ''
        description = 'Relation to ' + name
    }
    return [field.jsName, field.dbName, field.type, description]
}

/** Generate a comment for a model
 * @param {ModelType} model
 * @param {string} newlineChar
 * @returns {Promise<string>}
 */
export async function generateComment(model, newlineChar) {
    const columnTitles = ['JS Name', 'DB Name', 'DB Type', '']

    /** @type {ColumnValues[]} */
    const columnValues = []

    const sortedFields = _.sortBy(model._fields.getAll(), x => {
        if (x.jsName === 'id') {
            return '1'
        } else if (x.jsName === 'createdAt') {
            return '11'
        } else if (x.jsName === 'updatedAt') {
            return '111'
        }
        return x.jsName
    })
    for (const field of sortedFields) {
        columnValues.push(lineForField(field))
    }

    const longestContentForIdx = idx => {
        return Math.max(...columnValues.map(x => x[idx].length))
    }
    const columnWidths = columnTitles.map((title, idx) =>
        Math.max(title.length, longestContentForIdx(idx))
    )

    let cmt = newlineChar + `/** ${PRELUDE}` + newlineChar + '  *' + newlineChar
    const titlesLine = (
        `${padRight(columnTitles[0], columnWidths[0])} ` +
        `: ${padRight(columnTitles[1], columnWidths[1])} ` +
        `: ${padRight(columnTitles[2], columnWidths[2])} ` +
        `: ${padRight(columnTitles[3], columnWidths[3])}`
    ).trim()
    cmt += `  * ${titlesLine}` + newlineChar
    cmt += `  * ${'-'.repeat(titlesLine.length)}` + newlineChar
    for (const field of columnValues) {
        cmt +=
            '  ' +
            (
                `* ${padRight(field[0], columnWidths[0])} : ` +
                `${padRight(field[1], columnWidths[1])} : ` +
                `${padRight(field[2], columnWidths[2])} : ` +
                `${padRight(field[3], columnWidths[3])}`
            ).trim() +
            newlineChar
    }
    cmt += `  */` + newlineChar
    return cmt
}

/** Insert a comment into a file
 * @param {string} original
 * @param {number} start
 * @param {number} end
 * @param {string} content
 * @returns {string}
 */
export function insertComment(original, start, end, content) {
    const chopLength = end - start
    const result =
        original.substr(0, start) +
        content +
        original.substr(start + chopLength)
    return result
}

/** Generate a new comment for a model
 * @param {string} contentBefore
 * @param {ModelType} model
 * @returns {Promise<string>}
 */
export async function generateNewContent(contentBefore, model) {
    // does the file have our comment tag? if so start at the start of that,
    // and end at the end of that
    // otherwise just put start and end by the class definition

    const newlineChar = detectNewline.graceful(contentBefore)

    const { start, end } = await findStartEnd(contentBefore, model)
    const content = await generateComment(model, newlineChar)
    const inserted = await insertComment(contentBefore, start, end, content)
    return inserted
}

/** Generate a description for a model, print the result into the file
 * @param {ModelType} model
 * @returns {Promise<boolean>}
 */
async function descriptionGen(model) {
    const definingFile = await readFile(model._registeringPath, 'utf-8')

    const inserted = await generateNewContent(definingFile, model)
    const isSame = definingFile === inserted
    if (!isSame) {
        // write new contents
        console.log(
            `Writing new comment for model in ${model._registeringPath}!`
        )
        await writeFile(model._registeringPath, inserted, 'utf-8')
    }

    return true
}

export const modelsToGenerateDescriptionsFor = () => {
    return getLoadedUserModelList()
}

export const generateDescriptions = async () => {
    const generateDescriptions = get('models.generate_description')

    if (generateDescriptions) {
        /** @type {Promise<boolean>[]} */
        const proms = []
        const models = modelsToGenerateDescriptionsFor()
        for (const model of models) {
            proms.push(descriptionGen(model))
        }
        await Promise.all(proms)
    }
}
